# Modern Swift Library Architecture using Swift Packages

What are the best, modern practices for architecting your Swift Package or an ecosystem of Swift Packages? Picture this: you're building what seems like a simple HTML library, but six months later you're drowning in a 3,000-line monolith that's impossible to test, painful to maintain, and forces every consumer to import functionality they don't need. Sound familiar?

I recently released a brand new version of my `coenttb/swift-html` library that provides a domain-driven and type-safe approach to generating HTML and CSS. But here's the thing—this isn't just another HTML library. It's a case study in modern Swift package architecture that demonstrates how thoughtful modularization can transform a tangled mess into an elegant, composable ecosystem.

The tools are elegant, performant, and give you direct access to the underlying web technologies without unnecessary abstractions. And these tools were made possible by an ecosystem of carefully designed packages: `swift-html-types` and `swift-css-types`, which provide standards-compliant Swift APIs for HTML elements and CSS declarations, and `swift-html-css-pointfree`, which integrates this domain model with the HTML-printing capabilities of PointFreeHTML.

Now it's time to put this modular architecture to the test by exploring how these packages compose together to create a unified development experience. This is my exploration of modern Swift library architecture—the best practices for bringing complex, multi-package ecosystems into your Swift projects.

But here's where it gets interesting. We don't just want focused, reusable packages as the foundation of our libraries. We also want the benefits of:

- **Independent evolution**: Core domain types can remain stable and rarely change, while integration layers and developer ergonomics can iterate rapidly as we discover better APIs and patterns.

- **Selective dependencies**: Package consumers should be free to import only the functionality they need, reducing compile times and binary size. Some projects might only need HTML types for parsing, others might want the full rendering pipeline, and most likely in real-world, complex applications we will have a mixture of both.

- **Cross-project reuse**: You want to be able to share domain models across different contexts—a CSS processing library shouldn't need to pull in HTML rendering logic, and other HTML rendering engines don't want to have to import PointFreeHTML.

And if all of that wasn't complex enough, we further want to accomplish this with as few breaking changes as possible when packages evolve independently.

Oh, and one last thing that is important to us: we want each package to be independently testable too.

So, we have some fascinating architectural challenges ahead of us. The trade-off is increased complexity—more repositories to manage, more careful dependency design, and more potential for version conflicts. But here's the crucial insight: for libraries intended to be building blocks for other libraries, this flexibility creates a more sustainable and adaptable ecosystem.

To understand how we built this four-package ecosystem—and more importantly, how you can apply these patterns to your own projects—we need to start with the fundamental building blocks. When we talk about "importing functionality" and "selective dependencies," what exactly are we working with? The answer lies in understanding how Swift Package Manager organizes code.

## The building blocks: modules and packages

Swift Package Manager gives us a hierarchy of building blocks for organizing code, but the relationship between packages, products, targets, and modules can be confusing. And since we're going to be building an ecosystem of multiple packages, it's crucial we understand these building blocks first.

Here's what trips up most developers: they think packages and modules are the same thing. They're not. And this misunderstanding leads to architectural decisions that seem fine at first but become painful as projects grow.

For the purposes of this article, a **module** is anything you can `import` in Swift code—whether it's a system library like `Foundation`, a target you've defined in your own package, or a product from another Swift package your package depends on.

Think about it: when you write `import Foundation` or `import YourCustomLibrary`, you're importing modules. When someone creates a Swift package, other developers can `import` the libraries from that package.

My `coenttb/swift-html` package is itself a module because it's a library meant to be used by others. Some may use it to create HTML for their websites, others may use it to generate business documents like invoices. These clients can `import` the public APIs of `coenttb/swift-html` for their own purposes.

But here's where things get interesting: in modern library architecture, we don't just create one big module. We strategically break functionality into multiple, focused modules that can be imported independently. Someone building a CSS processor might only need `import CSSTypes` without pulling in any HTML rendering logic. A server-side tool might want `import HTMLTypes` without the PointFreeHTML integration.

And this is where the real power emerges: by understanding how packages, targets, and products relate to modules, we can architect systems that evolve gracefully, compose flexibly, and scale sustainably.

Swift Package Manager is our primary tool for creating these focused modules and orchestrating how they compose together. It gives us the building blocks—packages, targets, and products—to construct modular ecosystems where each piece has a single responsibility and clear boundaries.

Let's dive into these building blocks to see how they work together.

## What is a Swift Package?

Most Swift developers know about Swift packages, but here's what's fascinating: the concepts that seem most basic are often the ones that harbor the most architectural power. Let me show you what I mean.

The relationship between packages, products, targets, and modules can be confusing, but understanding it unlocks everything we're going to build. Let's break it down with a quick reference guide:

> **Quick Reference:**
> - **Package** = folder with a Package.swift file
> - **Product** = an externally visible build artifact available to clients of a package  
> - **Library** = a product that makes a target's public APIs available to import
> - **Target** = folder of source code located under /Sources in the package
> - **Module** = anything you can `import`
>     - Libraries can be imported by other packages that depend on this package
>     - Targets can be imported by other targets within the same package

The Package.swift file instantiates a Package type with products (such as libraries or executables) that are built from one or more targets. Libraries become modules that can be imported, while executables are standalone programs you can run.

But here's what most developers miss: this isn't just bureaucratic organization. These distinctions give us precise control over visibility, dependencies, and evolution. They're the tools we'll use to build our modular ecosystem.

### Building our first package: HTMLPackage

Let's make this concrete by creating an imaginary Swift Package called HTMLPackage from scratch. We'll use this as our playground to explore different architectural approaches—and more importantly, to see where each approach breaks down and why we need to evolve to the next level.

We start simple—just a folder and a single file:

```
HTMLPackage/
└── Package.swift
```

The `Package.swift` file begins with the bare minimum:

```swift
// swift-tools-version:6.0
import PackageDescription
let package = Package(
    name: "HTMLPackage"
)
```

But this isn't enough yet. Every Swift package needs a `Sources` folder containing at least one target folder with Swift source files:

```
HTMLPackage/
├── Package.swift
└── Sources/
    └── HTMLTarget/
        └── HTMLTarget.swift
```

Now we can complete our Package.swift by defining products and targets:

```swift
// swift-tools-version:6.0
import PackageDescription
let package = Package(
    name: "HTMLPackage",
    products: [
        .library(name: "HTMLLibrary", targets: ["HTMLTarget"]),
    ],
    targets: [
        .target(name: "HTMLTarget")
    ]
)
```

Perfect! We now have a complete Swift Package. HTMLPackage contains a library product called "HTMLLibrary" that exposes the "HTMLTarget" target. Other packages can depend on HTMLPackage and `import HTMLLibrary` to use our code.

But here's the thing: this simple structure is just the beginning. The real architectural decisions—and the real payoffs—come when we start asking harder questions: Should everything live in one target? One package? How do we organize code as complexity grows?

Let's find out by building something real.

## Adding some HTML types

Now let's add some actual Swift code to see our package in action. In `HTMLTarget.swift`, we'll create simple HTML element types that represent the building blocks of our DSL:

```swift
// HTMLTarget.swift
public struct Div {   
    public init() {}
}

// Also in HTMLTarget.swift
public struct Link {
    public let url: String
    
    public init(url: String) {
        self.url = url
    }
}
```

Great! This gives us basic `Div` and `Link` types for generating HTML. Other packages can now import our `HTMLLibrary` and use these types—our first step toward a type-safe HTML DSL.

But here's where things get interesting. There are over a hundred different HTML elements in the modern web platform. As we continue adding more types to `HTMLTarget.swift`—`Button`, `Form`, `Input`, `Table`, `Image`, and so on—this single file is going to become massive.

And that's where some fascinating architectural challenges start to emerge. Let me show you what I mean.

## The monolith approach: when simplicity becomes complexity

So we start adding more HTML elements to `HTMLTarget.swift`. First `Button`, then `Form`, then `Input`, `Table`, `Image`... and before we know it, we have a single file with over a hundred different HTML element types. That's easily 2,000+ lines of code in one file.

Picture this: you're six months into your HTML library project. Your single `HTMLTarget.swift` file has grown to 2,847 lines. A teammate wants to add support for the new `<dialog>` element, but they're afraid to touch the file because three other developers are already working in it. The last time someone tried to add a simple `<video>` element, it caused merge conflicts that took two hours to resolve.

And this creates some serious problems that go way beyond just "messy code":

- **Poor readability**: A single 2,000-line file is nearly impossible to navigate and understand at a glance. You spend more time scrolling than coding.
- **Coupling issues**: Everything in the same file has access to everything else, making it harder to enforce clean boundaries. Internal helper functions meant for `Button` can accidentally be used by `Table`, creating invisible dependencies.
- **Slow compilation**: Swift's compiler has to process the entire file even for small changes, increasing build times. Change one line in `Div`, wait for 2,000 lines to recompile.
- **Testing difficulties**: It becomes challenging to test individual components in isolation when everything is jumbled together. You can't test `Button` logic without potentially triggering side effects from `Form` code.
- **Merge conflicts**: Multiple developers working on the same large file inevitably leads to painful Git conflicts. And because everything's in one file, conflicts affect everyone.

But here's what makes this particularly insidious: these problems sneak up on you. At 50 lines, everything feels fine. At 200 lines, you start noticing compilation slowdowns but blame it on your machine. At 500 lines, you're spending real time scrolling to find things, but you tell yourself "I'll refactor this next sprint." By 2,000 lines, you're trapped.

Clearly, we need a better approach. But what's the right level of granularity?

## Breaking into multiple files: better, but not enough

The obvious next step is to create separate files within our HTMLTarget. We could have `Div.swift`, `Link.swift`, `Button.swift`, and so on. Each file has a focused purpose, making the codebase much more maintainable.

Let's update our folder structure:

```
HTMLPackage/
├── Package.swift
└── Sources/
    └── HTMLTarget/
        ├── Div.swift
        ├── Link.swift
        ├── LabelElement.swift
        ├── LabelAttribute.swift
        └── Button.swift
```

And we immediately get some nice benefits:
- **Reduced conflicts**: Multiple developers can work on different files simultaneously with fewer merge issues
- **Faster compilation**: Swift can compile files in parallel and only recompile changed files
- **Easier navigation**: Finding the `Button` implementation is now a simple file search

This is definitely better! Your team can finally work in parallel again. The compilation times improve. Life is good.

But as our HTML library grows, we start running into new problems that are subtler but ultimately more limiting.

The biggest issue is that code in different files within the same target can still access each other's internals freely. It becomes unclear which files depend on which others, making the codebase harder to understand and maintain as it grows. Your `Button.swift` file might start reaching into helpers defined in `Div.swift`, creating invisible coupling that's only discovered when someone tries to move or delete code.

Even worse: consumers must import the entire target even if they only need a small part of the functionality. Someone who just wants to use `Div` types still has to pull in all the `Button`, `Form`, and `Table` logic too. Their binary size grows, their compile times increase, and they're forced to track security updates for code they don't even use.

And here's a particularly nasty problem that you might not encounter for months: naming conflicts. Since all files share the same namespace, you can't have two types with the same name—even if they represent completely different concepts. HTML has nine cases where elements and attributes share names (like `label`, `cite`, and `form`). In a single target, you'd be forced to use artificial naming like `LabelElement` and `LabelAttribute`, polluting your API with implementation details rather than clean domain concepts.

Finally, you still can't test individual components in true isolation—they're all part of the same module. Your `Button` tests might accidentally depend on `Form` behavior, making your test suite brittle and harder to understand.

So while multiple files help with organization, we need to think bigger about our architecture. We need true boundaries, not just file boundaries.

## Breaking into multiple targets: where real modularity begins

So what if we take this organization one step further? Instead of just separate files, what if we create separate *targets*? This is where the real power of modularization first becomes apparent—and where we start to see the architectural patterns that will scale to truly complex systems.

Let's completely restructure our HTMLPackage to use multiple targets:

```swift
// swift-tools-version:6.0
import PackageDescription
let package = Package(
    name: "HTMLPackage",
    products: [
        .library(name: "HTMLElements", targets: ["HTMLElements"]),
        .library(name: "HTMLAttributes", targets: ["HTMLAttributes"]),
        .library(name: "HTMLPrinter", targets: ["HTMLPrinter"]),
    ],
    targets: [
        .target(name: "HTMLElements"),
        .target(name: "HTMLAttributes"),
        .target(
            name: "HTMLPrinter",
            dependencies: ["HTMLElements", "HTMLAttributes"]
        )
    ]
)
```

And our folder structure becomes:

```
HTMLPackage/
├── Package.swift
└── Sources/
    ├── HTMLElements/
    │   ├── Div.swift
    │   ├── Label.swift
    │   └── Link.swift
    ├── HTMLAttributes/
    │   ├── Class.swift
    │   ├── Href.swift
    │   └── Label.swift
    └── HTMLPrinter/
        └── HTMLPrinter.swift
```

Notice something fascinating? We can now have multiple files named `Label.swift`—one in HTMLElements for the label element, and another in HTMLAttributes for the label attribute. No more artificial naming like `LabelElement` and `LabelAttribute`! Each module gets its own namespace, so conflicts simply disappear.

We now have three separate modules, each with its own focused responsibility. HTMLElements contains our element types, HTMLAttributes contains our attribute types, and HTMLPrinter knows how to combine them into actual HTML output.

And here's where it gets really powerful. When another package depends on HTMLPackage, they can selectively import only what they need:

```swift
// In another package - cherry-pick your imports
import HTMLElements     // Just the HTML element types
import HTMLAttributes   // Just the HTML attribute types  
import HTMLPrinter      // The printer that combines both

// Now we can use the public APIs
let divType = Div()
let element = HTMLPrinter.createElement(divType)
```

But here's the crucial insight that changes everything: **Swift Package Manager enforces module boundaries at the compiler level.** You can only access public APIs of modules you've imported. This seemingly simple constraint unlocks tremendous benefits that ripple through your entire development process:

- **Clear API contracts**: We get precise control over what's exposed and what remains internal, encouraging proper encapsulation. Implementation details can't leak across module boundaries—the compiler won't let them.

- **Selective dependencies**: Consumers import only the functionality they need, reducing compile times and keeping dependencies minimal. A CSS processing library can import just `HTMLAttributes` without pulling in element types or printing logic.

- **Compile-time safety**: Dependencies become explicit and compiler-checked, catching integration issues early. If `HTMLPrinter` tries to access an internal function from `HTMLElements`, the code simply won't compile.

- **Maintenance boundaries**: Implementation details can't leak across module boundaries, making refactoring much safer. You can completely rewrite the internals of `HTMLElements` as long as you preserve the public API.

- **True testability**: Each module can be tested in complete isolation, leading to more focused and reliable tests. Your `HTMLElements` tests can't accidentally depend on `HTMLPrinter` behavior.

- **Parallel development**: Different teams can work on different modules independently, as long as they respect the public API contracts. The frontend team can iterate on `HTMLElements` while the backend team optimizes `HTMLPrinter`.

When we structure our packages this way, we enforce separation of concerns at the language level. The compiler becomes our friend, helping us maintain clean boundaries and making our code significantly easier to test and evolve over time.

But even this multi-target approach has its limits. As our HTML ecosystem grows beyond a single package's scope, we'll discover scenarios where we need to think even bigger...

## When one package isn't enough: the multi-package imperative

We showed why you benefit from using multiple targets for your code, and it's a massive improvement over the monolithic approach. But even the multi-target library has its limitations, especially when developing libraries that other libraries will depend on.

Here's where things get really interesting. While the multi-target library solves many problems, there are scenarios where separating functionality into entirely different Swift packages becomes not just beneficial, but necessary.

Let me paint you a picture of what happens as your library grows.

Consider our HTMLPackage example. What happens when different parts of your system need to evolve at different rates? Your HTMLElements types might be stable and rarely change—after all, the `<div>` element hasn't fundamentally changed in decades. But HTMLPrinter gets frequent updates with new features, performance optimizations, and bug fixes.

With a single package, every HTMLPrinter update forces consumers to potentially update their HTMLElements dependency too—even if they're not using any new HTMLPrinter features. Imagine you're building a CSS processing library that only needs the HTML attribute types. Every time the printer gets updated, your library's consumers have to deal with a dependency update, even though nothing they actually use has changed.

This becomes more problematic when you consider **cross-project reuse**. Picture this scenario: Another team wants to use your HTMLAttributes types in their CSS processing library, but they don't want to pull in HTMLElements or HTMLPrinter. Maybe they're building a CSS-in-JS system that only needs to know about CSS properties and HTML attributes—they have their own way of representing elements.

In a single package, they're forced to depend on functionality they don't need, increasing their binary size and creating unnecessary coupling. Worse, they might choose to reimplement your attribute types rather than take on the unwanted dependencies, leading to ecosystem fragmentation.

Team ownership also becomes complex as projects scale. Different teams might own different parts of the functionality. The type modeling team shouldn't be blocked by the builder team's release schedule, and vice versa. Different teams might want to iterate at different speeds, conduct different testing strategies, or even use different development practices.

I've seen this play out in real projects: the "core types" team wants to move slowly and carefully, ensuring stability and backward compatibility. Meanwhile, the "integration" team wants to iterate rapidly, trying new API designs and responding quickly to user feedback. In a single package, these different philosophies clash.

Finally, integration flexibility becomes constrained. You might want to provide multiple integration strategies—perhaps one that integrates with SwiftUI, another with server-side rendering, and a third with WebAssembly. Each integration shouldn't force consumers to pull in the others, but in a single package, this becomes difficult to manage cleanly.

But here's the thing that makes this particularly insidious: these problems don't appear immediately. They sneak up on you as your library becomes successful and gains more diverse users with different needs.

These challenges point to a fundamental insight: **modularity isn't just about code organization—it's about enabling independent evolution and flexible composition.**

When we move to separate packages, we unlock capabilities that simply aren't possible within a single package boundary:

- **Independent versioning**: Core types can remain stable at version 1.x while integrations evolve rapidly through 2.x, 3.x, and beyond
- **Precise dependencies**: Consumers pull in only what they need, nothing more—and the dependency graph makes this explicit
- **Cross-project reuse**: Domain models can be shared across different contexts without bringing along unrelated functionality
- **Compile-time guarantees**: The module system enforces clean boundaries and prevents accidental coupling between packages
- **Explicit dependency graphs**: It becomes impossible to create circular dependencies or unclear relationships between components

And here's a consideration that might seem peripheral but can be crucial: **legal and licensing considerations**. Different parts of your codebase might need different licenses. Your core domain types might be MIT licensed for maximum reusability, while your integration with a GPL-licensed library might need to be GPL itself. You can't have multiple licenses within a single package—each Swift package can only have one license.

This is where a **multi-package ecosystem** becomes not just useful, but essential. Instead of one HTMLPackage trying to be everything to everyone, we might have a carefully designed ecosystem where each package has a focused purpose.

## The anatomy of a multi-package ecosystem

Let me show you what this looks like in practice with the actual architecture I built for `coenttb/swift-html`. This isn't theoretical—it's a real system serving real users, and the architectural decisions were driven by actual problems I encountered while building and maintaining HTML tooling in Swift.

Here's how the packages compose:

```swift
// Package 1: swift-html-types
// The foundation: pure Swift types that model HTML elements and attributes
let package = Package(
    name: "swift-html-types",
    products: [
        .library(name: "HTMLAttributeTypes", targets: ["HTMLAttributeTypes"]),
        .library(name: "HTMLElementTypes", targets: ["HTMLElementTypes"]),
    ],
    targets: [
        .target(name: "HTMLAttributeTypes"),
        .target(name: "HTMLElementTypes")
    ]
)

// Package 2: swift-css-types  
// Pure CSS domain model, completely independent of HTML
let package = Package(
    name: "swift-css-types",
    products: [
        .library(name: "CSSTypes", targets: ["CSSTypes"]),
    ],
    targets: [
        .target(name: "CSSTypes")
    ]
)

// Package 3: pointfree-html
// Existing library that prints types to HTML strings
let package = Package(
    name: "pointfree-html",
    products: [
        .library(name: "PointFreeHTML", targets: ["PointFreeHTML"]),
    ],
    targets: [
        .target(name: "PointFreeHTML")
    ]
)

// Package 4: swift-html-css-pointfree
// Integration layer that composes everything together
let package = Package(
    name: "swift-html-css-pointfree",
    products: [
        .library(name: "HTMLCSSPointFree", targets: ["HTMLCSSPointFree"]),
    ],
    dependencies: [
        .package(url: "https://github.com/coenttb/swift-html-types", from: "1.0.0"),
        .package(url: "https://github.com/coenttb/swift-css-types", from: "2.0.0"),
        .package(url: "https://github.com/coenttb/pointfree-html", from: "0.4.0"),
    ],
    targets: [
        .target(
            name: "HTMLCSSPointFree",
            dependencies: [
                .product(name: "HTMLTypes", package: "swift-html-types"),
                .product(name: "CSSTypes", package: "swift-css-types"),
                .product(name: "Html", package: "swift-html"),
            ]
        )
    ]
)

// Package 5: swift-html
// Developer experience layer with high-level components
let package = Package(
    name: "swift-html",
    products: [
        .library(name: "HTML", targets: ["HTML"]),
    ],
    dependencies: [
        .package(url: "https://github.com/coenttb/swift-html-css-pointfree", from: "0.0.1"),
    ],
    targets: [
        .target(
            name: "HTML",
            dependencies: [
                .product(name: "HTMLCSSPointFree", package: "swift-html-css-pointfree"),
            ]
        )
    ]
)
```

And here's what makes this architecture so powerful:

**`swift-html-types`** provides the foundational domain model. It defines HTML elements, attributes, and document structure using pure Swift value types. This package is deliberately minimal and stable—it changes rarely because HTML itself changes rarely. A CSS processing library can depend on just this package to work with HTML attribute types without pulling in any rendering logic.

**`swift-css-types`** models CSS properties, values, and declarations as Swift types. It's completely independent of HTML—you could use it for CSS-in-JS systems, style processors, or any other CSS tooling. This separation means CSS innovations don't require HTML updates, and vice versa.

**`pointfree-html`** is an existing library that prints Swift types to actual HTML that can be rendered in a browser. By building on existing tools rather than reinventing everything, we get battle-tested HTML generation for free.

**`swift-html-css-pointfree`** provides the integration layer. It depends on both type packages and `pointfree-html`, adding the familiar `callAsFunction` pattern and CSS method chaining that makes the DSL feel natural. This is where the "magic" happens—where separate domain models compose into a unified development experience.

**`swift-html`** builds on this foundation with developer ergonomics and enhancements. It provides SwiftUI-like components (VStack, HStack), light/dark mode color support, and other conveniences. Because it sits at the top of the dependency graph, it can evolve rapidly without affecting the stable core types.

Now each package can:

1. **Evolve independently**: `swift-html-types` can reach version 2.0 while `swift-css-types` stays at 1.5, and consumers can mix and match versions as needed.

2. **Serve focused use cases**: A CSS processing tool can depend only on `swift-css-types` without pulling in HTML functionality.

3. **Maintain clear ownership**: Different teams can own different packages, with clear API contracts between them.

4. **Enable flexible integration**: `swift-html-css-pointfree` provides one integration strategy, but other packages could provide different approaches without conflicts—integration with [Elementary](https://github.com/sliemeobn/elementary), [Plot](https://github.com/JohnSundell/Plot), [HTMLKit](https://github.com/vapor-community/HTMLKit), and [Swim](https://github.com/robb/Swim), for example.

5. **Support semantic versioning**: Breaking changes in the integration layer don't require major version bumps in the stable type definitions.

The trade-off is increased complexity—more repositories to manage, more dependency resolution, and more potential for version conflicts. But for libraries intended to be building blocks for other libraries, this flexibility often outweighs the overhead.

And here's the crucial insight: **integration happens outside the core types**. The HTML and CSS domain models remain pure and focused, while the integration layer provides the developer experience. This follows the principle of composition over inheritance—rather than forcing HTML elements to know about CSS, we compose them together in a separate layer.

## How composition creates flexibility

This approach means you can:
- Use the HTML types with a different CSS system (maybe you prefer Tailwind-style utilities)
- Use the CSS types with a different HTML system (maybe you're building a React Native bridge)
- Swap out the integration layer for different API styles (maybe you prefer a more functional approach)
- Build entirely different integrations without changing the core types (maybe you want SwiftUI-style modifiers)

The packages form a clear dependency graph: `swift-html` depends on `swift-html-css-pointfree`, which depends on `swift-html-types`, `swift-css-types`, and `pointfree-html`. There are no circular dependencies, and each package has a single, focused responsibility.

But here's what makes this particularly elegant: if someone wants to build a completely different HTML DSL—maybe one that generates React components instead of raw HTML—they can reuse `swift-html-types` and `swift-css-types` without taking on any of the PointFree-specific integration code. The domain models become truly reusable building blocks.

## Common pitfalls and when NOT to split packages

Now, before you go splitting every module into its own package, let me share some hard-won wisdom about when this approach backfires.

**Premature optimization is real**: If you're building a small library that's unlikely to have diverse consumers, the overhead of multiple packages often isn't worth it. Start with multiple targets in a single package and split when you actually encounter the problems we've discussed.

**Version resolution hell**: Multiple packages mean multiple version constraints. If Package A needs `html-types 1.0` but Package B needs `html-types 2.0`, your consumers face impossible dependency resolution. Design your APIs carefully to minimize breaking changes in foundational packages.

**Development overhead**: More packages mean more repositories, more release processes, more CI configurations. Make sure you have the tooling and processes to handle this complexity before you commit to it.

**Circular dependencies by accident**: It's surprisingly easy to create circular dependencies when splitting packages. Always draw out your dependency graph before you start coding. If you find yourself wanting Package A to depend on Package B while Package B depends on Package A, you probably need to extract a third package with the shared functionality.

**Over-abstraction**: Sometimes trying to make everything reusable leads to APIs that are too generic to be useful. Don't sacrifice usability for theoretical flexibility unless you have concrete use cases driving the design.

Here are some rules of thumb I follow:

- **Start simple**: Begin with a single package and multiple targets. Only split when you have concrete evidence of the problems we've discussed.
- **Follow the users**: Split packages when you have different types of consumers with genuinely different needs, not when you think you might have them someday.
- **Optimize for stability**: Put the most stable, foundational types in the lowest-level packages. Save the experimental, rapidly-evolving stuff for higher-level packages.
- **Watch your dependency graph**: If your diagram looks like a spider web, you've probably over-engineered things.

## Real-world version resolution scenarios

Let me show you what version resolution looks like in practice, because this is where theoretical architecture meets real-world constraints.

Imagine you're building a web framework that depends on both my `swift-html` library and someone else's `swift-css-animations` library. Here's what might happen:

```swift
// Your web framework depends on:
.package(url: "https://github.com/coenttb/swift-html", from: "1.0.0")
.package(url: "https://github.com/someoneelse/swift-css-animations", from: "2.0.0")

// But swift-html internally depends on:
.package(url: "https://github.com/coenttb/swift-css-types", from: "1.5.0")

// And swift-css-animations also depends on:
.package(url: "https://github.com/coenttb/swift-css-types", from: "1.2.0")
```

Swift Package Manager will resolve this to `swift-css-types 1.5.0` because it satisfies both constraints. Everyone's happy.

But what if `swift-css-animations` required `swift-css-types 2.0.0` for some new feature? Now you'd have an unresolvable dependency conflict. Your users would be forced to choose between your web framework and the CSS animations library—not a great position to be in.

This is why the foundational packages in your ecosystem need to be extremely stable. Breaking changes in `swift-html-types` or `swift-css-types` ripple through the entire ecosystem and can create impossible situations for consumers.

## Tools and workflows for multi-package development

Managing multiple packages requires some tooling investment, but it pays dividends in the long run. Here's what's worked well for me:

**Local development setup**: Use local package overrides during development so you can work on multiple packages simultaneously:

```swift
// In your top-level package
.package(path: "../swift-html-types"),
.package(path: "../swift-css-types"),
```

**Automated testing**: Set up CI that tests not just individual packages, but also integration scenarios. You want to catch breaking changes before they reach consumers.

**Release automation**: Consider tools like [semantic-release](https://github.com/semantic-release/semantic-release) to automate version bumping and changelog generation across multiple repositories.

**Dependency updates**: Use tools like [Dependabot](https://github.com/dependabot) to keep dependencies current across all packages in your ecosystem.

**Documentation**: Maintain clear documentation about the relationships between packages. A simple architecture diagram can save new contributors hours of confusion.

## The "so what?" factor: why this complexity pays dividends

You might be thinking: "This seems like a lot of overhead for an HTML library. Why not just keep everything in one package and call it a day?"

And you're not wrong—it is more complex. But here's why that complexity pays dividends in ways that might not be immediately obvious:

**Ecosystem growth**: When your foundational types are reusable, other developers can build on them in ways you never imagined. The CSS types I built for HTML generation are now being used in server-side Swift projects, design system tools, and even code generation utilities. None of these use cases were in my original plan, but the modular architecture made them possible without any additional work on my part.

**Future-proofing**: Technology moves fast. Today you might be generating HTML for web servers, but tomorrow you might need to target WebAssembly, or generate React components, or create design tokens for mobile apps. With a modular architecture, you can swap out the integration layer while keeping your battle-tested domain models.

**Community contributions**: Different packages can have different maintainers and different release cycles. Someone passionate about CSS typography can focus on improving the CSS types without needing to understand HTML rendering. Someone else can optimize the HTML printer without worrying about breaking CSS functionality. This distributes maintenance burden and leads to better specialized knowledge in each area.

**Risk mitigation**: If a dependency becomes unmaintained or incompatible with your needs, you can swap it out without rewriting your entire system. When `pointfree-html` eventually gets replaced by something better (and it will), I can create a new integration package without touching any of the type definitions that users depend on.

**Testing confidence**: Each package can be thoroughly tested in isolation, leading to much higher confidence in the overall system. When I know that `swift-css-types` has 95% test coverage and handles all the edge cases correctly, I can focus my integration testing on the composition logic rather than re-testing every CSS property.

But perhaps most importantly: **it makes the impossible possible**. Complex software systems are built by composing simpler, focused components. By designing each package to do one thing extremely well, we create building blocks that can be combined in ways we never anticipated.

## Looking ahead: patterns you can apply

The HTML ecosystem is just one example of how these patterns can be applied. The same architectural principles work for many different domains:

**Networking libraries**: Core HTTP types, specific client implementations, and high-level convenience APIs can all be separate packages that compose together.

**Data processing**: JSON/CSV/XML types, parsing engines, and transformation utilities can evolve independently while working together.

**UI frameworks**: Core layout primitives, platform-specific renderers, and developer convenience APIs benefit from separation.

**Database tooling**: Schema types, query builders, and driver implementations can serve different consumers with different needs.

The key insight is to identify the **stable core** of your domain and separate it from the **evolving periphery**. Put the core concepts that rarely change in foundational packages, and build the rapidly-evolving convenience APIs on top.

Ask yourself:
- What parts of my system are most stable?
- Who are my different types of consumers, and what do they actually need?
- Where do I want to allow for future flexibility?
- What parts should be reusable across different contexts?

## The future of Swift package architecture

As the Swift ecosystem matures, I expect we'll see more libraries adopting these patterns. The most successful libraries will be those that can serve as building blocks for other libraries, not just end applications.

We're already seeing this with libraries like [sharing-grdb](https://github.com/pointfreeco/sharing-grdb), which builds on the more general [swift-sharing](https://github.com/pointfreeco/swift-sharing). 

The future belongs to **composable ecosystems** rather than monolithic frameworks. Users want the flexibility to pick and choose the pieces that make sense for their specific use case, and they want those pieces to work well together.

As library authors, our job is to create those well-designed pieces and the integration layers that make them feel like a unified whole.

## Conclusion: modularity as a design philosophy

Building modular Swift package ecosystems isn't just about organizing code—it's about enabling possibilities you can't yet imagine. When you design foundational packages that are focused, stable, and composable, you create opportunities for innovation that extend far beyond your original vision.

The HTML ecosystem I've built demonstrates these principles in action: stable domain types that rarely change, focused integration layers that can evolve rapidly, and clear boundaries that prevent accidental coupling. The result is a system that serves diverse use cases while maintaining coherence and simplicity.

But the real payoff isn't technical—it's human. Modular architectures enable collaborative development, distribute maintenance burden, and create opportunities for specialized expertise. They allow different parts of your system to evolve at different rates and serve different constituencies.

As you design your own Swift packages, remember that the goal isn't to create the perfect API today. It's to create a foundation that can evolve gracefully as you learn more about your problem domain and as your users discover new ways to apply your tools.

The best libraries are those that surprise their creators with what becomes possible. And that kind of emergent possibility is exactly what thoughtful modularization enables.

Start simple, split thoughtfully, and always optimize for the flexibility to be wrong about what the future holds. Because in software, as in life, the most interesting developments are usually the ones you never saw coming.

---

*This series continues with deep dives into each package in the ecosystem. Next up: how `swift-html-types` models the entire HTML specification as Swift types, and why getting the foundation right matters for everything that follows.*
