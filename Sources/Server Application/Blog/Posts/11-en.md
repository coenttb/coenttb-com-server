# Modern Swift Library Architecture using Swift Packages

In my next series, we take a tour of `swift-html-types`, `swift-css-types`, `swift-html-css-pointfree`, and - ultimately, `swift-html`, to understand how they work and how to use them to create type-safe, composable HTML using Swift - much like SwiftUI.

Before that though, I want to take a step back and go over the overarching architecture. For example, why are these all separate packages, and not just one package?  

## What is a module?

For the purpose of this series, a module is anything you can import in Swift code. So in a Swift package, modules include both the targets you define and the products you import from dependencies.

Most Swift developers know about Swift packages, but the relationship between packages, products, targets, and modules can be confusing. Let's break it down:

Let's clarify: 
- A Swift Package is a folder with a Package.swift file. 
- The Package.swift file instantiats a Package type with products (libraries or executables) that are built from targets (folders of source code).
    - Products can be imported by other packages that depend on this package.
    - Targets can be imported by other targets within the same package.

> Tip: The difference between a library and an executable is that libraries are imported by other code, while executables are programs you can run. Libraries become modules that can be imported, while executables are standalone programs.

Lets take a look at a concrete example. We will make an imaginary Swift Package titled HTMLPackage. We start by creating a normal folder called "HTMLPackage". 

In this folder, we create a new file titled `Package.swift`, with the following contents:

```swift
// swift-tools-version:6.0
import PackageDescription
let package = Package(
    name: "HTMLPackage",
    products: [
        .library(name: "HTMLLibrary", targets: ["HTMLTarget"]),
    ],
    targets: [
        .target(
            name: "HTMLTarget"
        )
    ]
)
```

> Tip: `// swift-tools-version:6.0` declares the version of the swift-tools, and `import PackageDescription` imports the Package type and related types necessary for the Package.swift.

> Note: Each Swift package must also have at least a folder titled `Sources`. `Sources` is a folder of folders, where each subfolder corresponds to a target. For the above example - our HTMLPackage - the `Sources` folder will contain one folder, titled "HTMLTarget". Each target must have at least one swift file in it. In our example, we'll call that file HTMLTarget.swift.
> 
> Your folder structure now look like this:
> 
> ```
> HTMLPackage/
> ├── Package.swift
> └── Sources/
>     └── HTMLTarget/
>         └── HTMLTarget.swift
> ```

This is all it takes to create a Swift Package titled HTMLPackage, which contains a product of the library type called "HTMLLibrary", which exposes the "HTMLTarget" target.

### The Monolith target

Now, as you continue to write code in HTMLTarget.swift, the file becomes larger and larger. This creates several problems:

1. Poor readability: A single 2,000-line file is nearly impossible to navigate and understand at a glance.
1. Coupling issues: Everything in the same file has access to everything else, making it harder to enforce clean boundaries.
1. Slow compilation: Swift's compiler has to process the entire file even for small changes, increasing build times.
1. Testing difficulties: It becomes challenging to test individual components in isolation when everything is jumbled together.
1. Merge conflicts: Multiple developers working on the same large file inevitably leads to painful Git conflicts.

### The multi-file target

> Note: Your folder structure now look like this:
>  
> ```
> HTMLPackage/
> ├── Package.swift
> └── Sources/
>     └── HTMLTarget/
>         ├── HTMLTarget.swift
>         ├── A.swift
>         └── Div.swift
> ```

The next step is to create more files in the HTMLTarget. You could have one for the `div` type, one for the `a` type, and so on. This helps initially because related functionality can be grouped into logical files (Div.swift, A.swift, etc.). Each file has a focused purpose, making the codebase more maintainable.

Additionally, we get the following benefits from separating into different files:
1. Reduced conflicts: Multiple developers can work on different files simultaneously with fewer merge issues.
1. Faster compilation: Swift can compile files in parallel and only recompile changed files.

However, just separating into files doesn't scale well because code in different files in the target can still access each other's internals freely. It then becomes unclear which files depend on which others, making the codebase harder to understand and maintain. And equally bad: Consumers must import the entire target even if they only need a small part of the functionality. Naming conflicts also become problematic. Since all files share the same namespace, you can't have two types with the same name—even if they represent completely different concepts. For example, HTML has nine cases where elements and attributes share names (like label, cite, and form). In a single target, you'd be forced to use artificial naming like LabelElement and LabelAttribute, polluting your API with implementation details rather than clean domain concepts. Finally, separating into separate files only, you still can't test individual components in true isolation—they're all part of the same module.

### The multi-target library

Then you will separate into separate targets, possibly separate libraries even. This is where the real power of modularization becomes apparent.

Let's extend our HTMLPackage example to show multiple targets:

```swift
// swift-tools-version:6.0
import PackageDescription
let package = Package(
    name: "HTMLPackage",
    products: [
        .library(name: "HTMLElements", targets: ["HTMLElements"]),
        .library(name: "HTMLAttributes", targets: ["HTMLAttributes"]),
        .library(name: "HTMLBuilder", targets: ["HTMLBuilder"]),
    ],
    targets: [
        .target(name: "HTMLElements"),
        .target(name: "HTMLAttributes"),
        .target(
            name: "HTMLBuilder",
            dependencies: ["HTMLElements", "HTMLAttributes"]
        )
    ]
)
```

> Note: Your folder structure now look like this:
> 
> ```
> HTMLPackage/
> ├── Package.swift
> └── Sources/
>     ├── HTMLElements/
>     │   ├── Label.swift
>     │   ├── Div.swift
>     │   └── A.swift
>     ├── HTMLAttributes/
>     │   ├── Label.swift
>     │   ├── Class.swift
>     │   └── Href.swift
>     └── HTMLBuilder/
>         └── HTMLBuilder.swift
> ```
> We can now have multiple files named Label.swift - excellent!

Now we have three separate modules, each with its own focused responsibility. The HTMLBuilder target depends on both HTMLElements and HTMLAttributes, creating an explicit dependency graph.

When another package—let's call it "Swift Package A"—depends on HTMLPackage, Swift Package A can selectively import only the products it needs:

```swift
// In Package A - only import what you need
import HTMLElements     // Just the HTML Element types
import HTMLAttributes   // Just the HTML Attribute types  
import HTMLBuilder      // The builder that combines both

// Or import multiple at once
import HTMLElements
import HTMLBuilder

// Now we can use public APIs from these modules
let divType = Div()
let element = HTMLBuilder.createElement(divType)
```

But here's the key insight: in Swift Package Manager, the compiler enforces module boundaries for targets, which means you can only access public APIs of modules you've imported.

This boundary is incredibly valuable for several reasons:

1. **Clear API contracts**: Modules give us precise control over what's exposed and what remains internal, encouraging proper encapsulation.
1. **Selective dependencies**: Consumers can import only the functionality they need, reducing compile times and keeping dependencies minimal.
1. **Compile-time safety**: Dependencies become explicit and compiler-checked, catching integration issues early.
1. **Maintenance boundaries**: In a well-modularized codebase, implementation details don't leak across module boundaries, making refactoring safer.
1. **True testability**: Each module can be tested in complete isolation, leading to more focused and reliable tests.
1. **Parallel development**: Different teams can work on different modules independently, as long as they respect the public API contracts.

When we structure our packages thoughtfully, we can enforce separation of concerns at the language level, keep codebases maintainable, and make them significantly easier to test and evolve over time.

## Composition of Swift Package libraries

We showed why you benefit from using multiple targets for your code. But even the multi-target approach has its limitations, especially when developing libraries. While the multi-target library solves many problems, there are scenarios where separating functionality into entirely different Swift packages becomes necessary.

Consider our HTMLPackage example. What happens when different parts of your system need to evolve at different rates? Your HTMLElements types might be stable and rarely change, but HTMLBuilder gets frequent updates with new features. With a single package, every HTMLBuilder update forces consumers to potentially update their HTMLElements dependency too—even if they're not using any new HTMLBuilder features.

This becomes more problematic when you consider **cross-project reuse**. Another team might want to use your HTMLAttributes types in their CSS processing library, but they don't want to pull in HTMLElements or HTMLBuilder. In a single package, they're forced to depend on functionality they don't need, increasing their binary size and creating unnecessary coupling.

**Dependency conflicts** present another challenge. HTMLBuilder might need a specific version of a parsing library, while HTMLElements needs a different version of the same library. Within a single package, you can't have conflicting dependency requirements—everything must align on compatible versions.

**Team ownership** also becomes complex. Different teams might own different parts of the functionality. The type modeling team shouldn't be blocked by the builder team's release schedule, and vice versa. Different teams might want to iterate at different speeds, conduct different testing strategies, or even use different development practices.

Finally, **integration flexibility** becomes constrained. You might want to provide multiple integration strategies—perhaps one that integrates with SwiftUI, another with server-side rendering, and a third with WebAssembly. Each integration shouldn't force consumers to pull in the others, but in a single package, this becomes difficult to manage cleanly.

These challenges point to a fundamental insight: **modularity isn't just about code organization—it's about enabling independent evolution and flexible composition**. When we move to separate packages, we unlock:

- **Independent versioning**: Core types can remain stable while integrations evolve rapidly
- **Precise dependencies**: Consumers pull in only what they need, nothing more
- **Cross-project reuse**: Domain models can be shared across different contexts without bringing along unrelated functionality
- **Compile-time guarantees**: The module system enforces clean boundaries and prevents accidental coupling
- **Explicit dependency graphs**: It becomes impossible to create circular dependencies or unclear relationships between components

This is where a **multi-package ecosystem** becomes valuable. Instead of one HTMLPackage, we might have:

```swift
// Package 1: swift-html-types
let package = Package(
    name: "swift-html-types",
    products: [
        .library(name: "HTMLAttributeTypes", targets: ["HTMLAttributeTypes"]),
        .library(name: "HTMLElementTypes", targets: ["HTMLElementTypes"]),
    ],
    targets: [
        .target(name: "HTMLAttributeTypes"),
        .target(name: "HTMLElementTypes")
    ]
)

// Package 2: swift-css-types  
let package = Package(
    name: "swift-css-types",
    products: [
        .library(name: "CSSTypes", targets: ["CSSTypes"]),
    ],
    targets: [
        .target(name: "CSSTypes")
    ]
)

// Package 3: swift-html-css-pointfree
let package = Package(
    name: "swift-html-css-pointfree",
    products: [
        .library(name: "HTMLCSSPointFree", targets: ["HTMLCSSPointFree"]),
    ],
    dependencies: [
        .package(url: "https://github.com/coenttb/swift-html-types", from: "1.0.0"),
        .package(url: "https://github.com/coenttb/swift-css-types", from: "2.0.0"),
        .package(url: "https://github.com/pointfreeco/swift-html", from: "0.4.0"),
    ],
    targets: [
        .target(
            name: "HTMLCSSPointFree",
            dependencies: [
                .product(name: "HTMLTypes", package: "swift-html-types"),
                .product(name: "CSSTypes", package: "swift-css-types"),
                .product(name: "Html", package: "swift-html"),
            ]
        )
    ]
)
```

Now each package can:

1. **Evolve independently**: swift-html-types can reach version 2.0 while swift-css-types stays at 1.5, and consumers can mix and match versions as needed.
1. **Serve focused use cases**: A CSS processing tool can depend only on swift-css-types without pulling in HTML functionality.
1. **Maintain clear ownership**: Different teams can own different packages, with clear API contracts between them.
1. **Enable flexible integration**: swift-html-css-pointfree provides one integration strategy, but other packages could provide different approaches ([Elementary](https://github.com/sliemeobn/elementary), [Plot](https://github.com/JohnSundell/Plot), [HTMLKit](https://github.com/vapor-community/HTMLKit), and [Swim](https://github.com/robb/Swim) integration, for example) without conflicts.
1. **Support semantic versioning**: Breaking changes in the integration layer don't require major version bumps in the stable type definitions.
1. **Legal and licensing considerations**: Different parts of your codebase might need different licenses. Your core domain types might be MIT licensed for maximum reusability, while your integration with a GPL-licensed library might need to be GPL itself. You can't have multiple licenses within a single package—each Swift package can only have one license.

The trade-off is increased complexity—more repositories to manage, more dependency resolution, and more potential for version conflicts. But for libraries intended to be building blocks for other libraries, this flexibility often outweighs the overhead.

## A concrete example: the swift-html ecosystem

This multi-package approach is exactly what we've implemented with the `swift-html` ecosystem, where each package serves a specific, focused purpose while building upon the others.

**swift-html-types** provides the foundational domain model. It defines HTML elements, attributes, and document structure using pure Swift value types. This package is deliberately minimal and stable—it changes rarely because HTML itself changes rarely. A CSS processing library can depend on just this package to work with HTML attribute types without pulling in any rendering logic.

**swift-css-types** models CSS properties, values, and declarations as Swift types. It's completely independent of HTML—you could use it for CSS-in-JS systems, style processors, or any other CSS tooling. This separation means CSS innovations don't require HTML updates, and vice versa.

**swift-html-css-pointfree** provides the integration layer. It depends on both type packages and Point-Free's `swift-html` library, adding the familiar `callAsFunction` pattern and CSS method chaining that makes the DSL feel natural. This is where the "magic" happens—where separate domain models compose into a unified development experience.

**swift-html** builds on this foundation with developer ergonomics and enhancements. It provides SwiftUI-like components (VStack, HStack), light/dark mode color support, and other conveniences. Because it sits at the top of the dependency graph, it can evolve rapidly without affecting the stable core types.

## How the packages compose

The key insight is that **integration happens outside the core types**. The HTML and CSS domain models remain pure and focused, while the integration layer provides the developer experience. This follows the principle of composition over inheritance—rather than forcing HTML elements to know about CSS, we compose them together in a separate layer.

This approach means you can:
- Use the HTML types with a different CSS system
- Use the CSS types with a different HTML system  
- Swap out the integration layer for different API styles
- Build entirely different integrations (server-side rendering, WebAssembly, etc.) without changing the core types

The packages form a clear dependency graph: swift-html depends on swift-html-css-pointfree, which depends on both swift-html-types and swift-css-types. There are no circular dependencies, and each package has a single, focused responsibility.

## Looking ahead

In the upcoming posts, we'll dive deep into each package:

1. **swift-html-types**: How we model HTML elements and attributes as Swift types, and why this foundation matters for everything that follows
2. **swift-css-types**: Building a complete CSS type system, from properties to selectors to media queries
3. **swift-html-css-pointfree**: The integration magic—how `callAsFunction` and method chaining create a SwiftUI-like HTML DSL
4. **swift-html**: Developer ergonomics, components, and the final experience

This series is for library authors who want to understand modular architecture, SwiftUI developers curious about similar patterns in other domains, and anyone building web tooling in Swift. We'll explore not just how these packages work, but why they're designed the way they are—and how you can apply similar principles to your own projects.

The goal isn't just to build another HTML library, but to demonstrate how thoughtful modularization can create flexible, composable systems that evolve gracefully over time. By the end, you'll have a complete picture of how separate packages can work together to create something more powerful than any single monolithic solution.
